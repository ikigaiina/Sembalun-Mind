/**
 * Production-Ready Performance Monitor
 * Comprehensive performance tracking with memory leak detection
 */

import React from 'react';

interface PerformanceMetrics {
  timeToInteractive: number;
  memoryUsage: number;
  renderCount: number;
  componentMountTime: number;
  audioLoadTime: number;
  bundleSize: number;
  lastUpdated: number;
}

interface ComponentMetrics {
  name: string;
  renderCount: number;
  mountTime: number;
  updateTime: number;
  unmountTime: number;
  averageRenderTime: number;
  memoryLeaks: boolean;
}

interface MemorySnapshot {
  timestamp: number;
  heapUsed: number;
  heapTotal: number;
  external: number;
  componentInstances: Map<string, number>;
  eventListeners: number;
  timers: number;
}

class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  private metrics: PerformanceMetrics;
  private componentMetrics: Map<string, ComponentMetrics> = new Map();
  private memorySnapshots: MemorySnapshot[] = [];
  private renderObserver: PerformanceObserver | null = null;
  private memoryLeakTimer: NodeJS.Timeout | null = null;
  private isEnabled: boolean = true;

  private constructor() {
    this.metrics = {
      timeToInteractive: 0,
      memoryUsage: 0,
      renderCount: 0,
      componentMountTime: 0,
      audioLoadTime: 0,
      bundleSize: 0,
      lastUpdated: Date.now()
    };

    this.initializePerformanceObserver();
    this.startMemoryMonitoring();
  }

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  private initializePerformanceObserver(): void {
    if (typeof window === 'undefined' || !('PerformanceObserver' in window)) return;

    try {
      this.renderObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'measure' && entry.name.includes('React')) {
            this.updateRenderMetrics(entry.name, entry.duration);
          }
        });
      });

      this.renderObserver.observe({ entryTypes: ['measure'] });
    } catch (error) {
      console.warn('Performance Observer not supported:', error);
    }
  }

  private startMemoryMonitoring(): void {
    if (typeof window === 'undefined') return;

    this.memoryLeakTimer = setInterval(() => {
      this.captureMemorySnapshot();
      this.detectMemoryLeaks();
    }, 30000); // Check every 30 seconds
  }

  private captureMemorySnapshot(): void {
    if (!('performance' in window) || !('memory' in (window.performance as any))) return;

    const memory = (window.performance as any).memory;
    const snapshot: MemorySnapshot = {
      timestamp: Date.now(),
      heapUsed: memory.usedJSHeapSize,
      heapTotal: memory.totalJSHeapSize,
      external: memory.usedJSHeapSize - memory.totalJSHeapSize,
      componentInstances: new Map(),
      eventListeners: this.countEventListeners(),
      timers: this.countTimers()
    };

    this.memorySnapshots.push(snapshot);

    // Keep only last 10 snapshots
    if (this.memorySnapshots.length > 10) {
      this.memorySnapshots.shift();
    }

    this.metrics.memoryUsage = memory.usedJSHeapSize;
  }

  private countEventListeners(): number {
    // Estimate based on common patterns
    let count = 0;
    try {
      const elements = document.querySelectorAll('*');
      elements.forEach((el) => {
        const events = (el as any)._events || {};
        count += Object.keys(events).length;
      });
    } catch (error) {
      // Fallback estimation
      count = document.querySelectorAll('[onclick], [onchange], [onsubmit]').length;
    }
    return count;
  }

  private countTimers(): number {
    // Estimate active timers (this is a simplified approach)
    return (window as any)._activeTimers?.size || 0;
  }

  private detectMemoryLeaks(): void {
    if (this.memorySnapshots.length < 3) return;

    const recent = this.memorySnapshots.slice(-3);
    const isIncreasing = recent.every((snapshot, index) => {
      if (index === 0) return true;
      return snapshot.heapUsed > recent[index - 1].heapUsed;
    });

    if (isIncreasing) {
      const growthRate = (recent[2].heapUsed - recent[0].heapUsed) / recent[0].heapUsed;
      if (growthRate > 0.1) { // 10% growth threshold
        console.warn('Potential memory leak detected', {
          growthRate: `${(growthRate * 100).toFixed(2)}%`,
          currentHeap: `${(recent[2].heapUsed / 1024 / 1024).toFixed(2)}MB`,
          eventListeners: recent[2].eventListeners,
          timers: recent[2].timers
        });
      }
    }
  }

  private updateRenderMetrics(componentName: string, duration: number): void {
    const existing = this.componentMetrics.get(componentName);
    
    if (existing) {
      existing.renderCount++;
      existing.averageRenderTime = (existing.averageRenderTime + duration) / 2;
      existing.updateTime = Date.now();
    } else {
      this.componentMetrics.set(componentName, {
        name: componentName,
        renderCount: 1,
        mountTime: Date.now(),
        updateTime: Date.now(),
        unmountTime: 0,
        averageRenderTime: duration,
        memoryLeaks: false
      });
    }

    this.metrics.renderCount++;
    this.metrics.lastUpdated = Date.now();
  }

  // Public API
  markComponentMount(componentName: string): void {
    if (!this.isEnabled) return;

    const existing = this.componentMetrics.get(componentName);
    if (existing) {
      existing.mountTime = Date.now();
    } else {
      this.componentMetrics.set(componentName, {
        name: componentName,
        renderCount: 0,
        mountTime: Date.now(),
        updateTime: 0,
        unmountTime: 0,
        averageRenderTime: 0,
        memoryLeaks: false
      });
    }
  }

  markComponentUnmount(componentName: string): void {
    if (!this.isEnabled) return;

    const existing = this.componentMetrics.get(componentName);
    if (existing) {
      existing.unmountTime = Date.now();
    }
  }

  measureTimeToInteractive(): void {
    if (!this.isEnabled || typeof window === 'undefined') return;

    // Use Navigation Timing API
    if ('performance' in window && 'timing' in window.performance) {
      const timing = window.performance.timing;
      this.metrics.timeToInteractive = timing.domInteractive - timing.navigationStart;
    }
  }

  measureAudioLoadTime(startTime: number): void {
    if (!this.isEnabled) return;
    this.metrics.audioLoadTime = Date.now() - startTime;
  }

  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }

  getComponentMetrics(): ComponentMetrics[] {
    return Array.from(this.componentMetrics.values());
  }

  getMemorySnapshots(): MemorySnapshot[] {
    return [...this.memorySnapshots];
  }

  generateReport(): string {
    const report = {
      timestamp: new Date().toISOString(),
      metrics: this.getMetrics(),
      components: this.getComponentMetrics(),
      memory: this.getMemorySnapshots(),
      recommendations: this.generateRecommendations()
    };

    return JSON.stringify(report, null, 2);
  }

  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    const components = this.getComponentMetrics();

    // High render count detection
    components.forEach(comp => {
      if (comp.renderCount > 50) {
        recommendations.push(`Consider memoizing ${comp.name} - ${comp.renderCount} renders detected`);
      }
      if (comp.averageRenderTime > 16) {
        recommendations.push(`${comp.name} rendering slower than 60fps - ${comp.averageRenderTime.toFixed(2)}ms average`);
      }
    });

    // Memory recommendations
    if (this.metrics.memoryUsage > 50 * 1024 * 1024) { // 50MB
      recommendations.push('High memory usage detected - consider implementing lazy loading');
    }

    // Audio performance
    if (this.metrics.audioLoadTime > 3000) {
      recommendations.push('Audio loading time exceeds 3 seconds - implement preloading');
    }

    return recommendations;
  }

  disable(): void {
    this.isEnabled = false;
    if (this.renderObserver) {
      this.renderObserver.disconnect();
    }
    if (this.memoryLeakTimer) {
      clearInterval(this.memoryLeakTimer);
    }
  }

  enable(): void {
    this.isEnabled = true;
    this.initializePerformanceObserver();
    this.startMemoryMonitoring();
  }
}

// React Hook for component performance tracking
export const usePerformanceTracking = (componentName: string) => {
  const monitor = PerformanceMonitor.getInstance();

  React.useEffect(() => {
    monitor.markComponentMount(componentName);

    return () => {
      monitor.markComponentUnmount(componentName);
    };
  }, [componentName, monitor]);

  const measureRender = React.useCallback((callback: () => void) => {
    const startTime = performance.now();
    callback();
    const endTime = performance.now();
    
    // Manual render time tracking
    const duration = endTime - startTime;
    if (duration > 0) {
      (monitor as any).updateRenderMetrics(componentName, duration);
    }
  }, [componentName, monitor]);

  return { measureRender };
};

// Higher-Order Component for automatic performance tracking
export const withPerformanceTracking = <P extends object>(
  WrappedComponent: React.ComponentType<P>,
  componentName?: string
) => {
  const displayName = componentName || WrappedComponent.displayName || WrappedComponent.name || 'Component';

  const TrackedComponent = React.memo((props: P) => {
    const { measureRender } = usePerformanceTracking(displayName);

    return (
      <React.Profiler
        id={displayName}
        onRender={(id, phase, actualDuration) => {
          if (actualDuration > 0) {
            PerformanceMonitor.getInstance().updateRenderMetrics(id, actualDuration);
          }
        }}
      >
        <WrappedComponent {...props} />
      </React.Profiler>
    );
  });

  TrackedComponent.displayName = `withPerformanceTracking(${displayName})`;
  return TrackedComponent;
};

export default PerformanceMonitor;